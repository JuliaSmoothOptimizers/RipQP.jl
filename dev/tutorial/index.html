<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · RipQP.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RipQP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">RipQP.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../API/">API</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Input"><span>Input</span></a></li><li><a class="tocitem" href="#Solve-the-problem-and-read-the-statistics"><span>Solve the problem and read the statistics</span></a></li><li><a class="tocitem" href="#Logging"><span>Logging</span></a></li><li><a class="tocitem" href="#Change-configuration-and-tolerances"><span>Change configuration and tolerances</span></a></li><li><a class="tocitem" href="#Save-the-Interior-Point-system"><span>Save the Interior-Point system</span></a></li><li><a class="tocitem" href="#Advanced:-write-your-own-solver"><span>Advanced: write your own solver</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Input"><a class="docs-heading-anchor" href="#Input">Input</a><a id="Input-1"></a><a class="docs-heading-anchor-permalink" href="#Input" title="Permalink"></a></h2><p>RipQP uses the package <a href="https://github.com/JuliaSmoothOptimizers/QuadraticModels.jl">QuadraticModels.jl</a> to model convex quadratic problems.</p><p>Here is a basic example:</p><pre><code class="language-julia">using QuadraticModels
Q = [6. 2. 1.
    2. 5. 2.
    1. 2. 4.]
c = [-8.; -3; -3]
A = [1. 0. 1.
    0. 2. 1.]
b = [0.; 3]
l = [0.;0;0]
u = [Inf; Inf; Inf]
QM = QuadraticModel(c, Q, A=A, lcon=b, ucon=b, lvar=l, uvar=u, c0=0., name=&quot;QM&quot;)</code></pre><p>It is also possible to use the package <a href="https://github.com/JuliaSmoothOptimizers/QPSReader.jl">QPSReader.jl</a> in order to read convex quadratic problems in MPS or SIF formats:</p><pre><code class="language-julia">using QPSReader, QuadraticModels
QM = QuadraticModel(readqps(&quot;QAFIRO.SIF&quot;))</code></pre><h2 id="Solve-the-problem-and-read-the-statistics"><a class="docs-heading-anchor" href="#Solve-the-problem-and-read-the-statistics">Solve the problem and read the statistics</a><a id="Solve-the-problem-and-read-the-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-problem-and-read-the-statistics" title="Permalink"></a></h2><p>Once your <code>QuadraticModel</code> is loaded, you can simply solve it with:</p><pre><code class="language-julia">using RipQP
stats = ripqp(QM)</code></pre><p>The <code>stats</code> output is a <a href="https://juliasmoothoptimizers.github.io/SolverCore.jl/dev/reference/#SolverCore.GenericExecutionStats">GenericExecutionStats</a>.</p><h2 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h2><p>RipQP displays some logs at each iterate.</p><p>You can deactivate logging with</p><pre><code class="language-julia">stats = ripqp(QM, display = false)</code></pre><h2 id="Change-configuration-and-tolerances"><a class="docs-heading-anchor" href="#Change-configuration-and-tolerances">Change configuration and tolerances</a><a id="Change-configuration-and-tolerances-1"></a><a class="docs-heading-anchor-permalink" href="#Change-configuration-and-tolerances" title="Permalink"></a></h2><p>The <a href="../API/#RipQP.InputConfig"><code>RipQP.InputConfig</code></a> type allows the user to change the configuration of RipQP. For example, you can use the multi-precision mode without scaling with:</p><pre><code class="language-julia">stats = ripqp(QM, iconf = InputConfig(mode = :multi, scaling = false))</code></pre><p>You can also change the <a href="../API/#RipQP.InputTol"><code>RipQP.InputTol</code></a> type to change the tolerances for the stopping criteria:</p><pre><code class="language-julia">stats = ripqp(QM, itol = InputTol(max_iter = 100, ϵ_rb = 1.0e-4),
              iconf = InputConfig(mode = :multi, scaling = false))</code></pre><h2 id="Save-the-Interior-Point-system"><a class="docs-heading-anchor" href="#Save-the-Interior-Point-system">Save the Interior-Point system</a><a id="Save-the-Interior-Point-system-1"></a><a class="docs-heading-anchor-permalink" href="#Save-the-Interior-Point-system" title="Permalink"></a></h2><p>At every iteration, RipQP solves two linear systems with the default Predictor-Corrector method (the affine system and the  corrector-centering system), or one linear system with the Infeasible Path-Following method.</p><p>To save these systems, you can use:</p><pre><code class="language-julia">w = SystemWrite(write = true, name=&quot;test_&quot;, kfirst = 4, kgap=3) 
stats1 = ripqp(QM, iconf = InputConfig(w = w))</code></pre><p>This will save one matrix and the associated two right hand sides of the PC method every three iterations starting at  iteration four. Then, you can read the saved files with:</p><pre><code class="language-julia">using DelimitedFiles, MatrixMarket
K = MatrixMarket.mmread(&quot;test_K_iter4.mtx&quot;)
rhs_aff = readdlm(&quot;test_rhs_iter4_aff.rhs&quot;, Float64)[:]
rhs_cc =  readdlm(&quot;test_rhs_iter4_cc.rhs&quot;, Float64)[:] </code></pre><h2 id="Advanced:-write-your-own-solver"><a class="docs-heading-anchor" href="#Advanced:-write-your-own-solver">Advanced: write your own solver</a><a id="Advanced:-write-your-own-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-write-your-own-solver" title="Permalink"></a></h2><p>You can use your own solver to compute the direction of descent inside RipQP at each iteration. Here is a basic example using the package <a href="https://github.com/JuliaSmoothOptimizers/LDLFactorizations.jl"><code>LDLFactorizations.jl</code></a>.</p><p>First, you will need a <a href="../API/#RipQP.SolverParams"><code>RipQP.SolverParams</code></a> to define parameters for your solver:</p><pre><code class="language-julia">using RipQP, LinearAlgebra, LDLFactorizations, SparseArrays

struct K2basicLDLParams{T&lt;:Real} &lt;: SolverParams
    ρ :: T # dual regularization
    δ :: T # primal regularization
end</code></pre><p>Then, you will have to create a type that allocates space for your solver, and a constructor using the following parameters:</p><pre><code class="language-julia">mutable struct PreallocatedData_K2basic{T&lt;:Real} &lt;: RipQP.PreallocatedData{T}
    D                :: Vector{T} # temporary top-left diagonal of the K2 system
    ρ                :: T # dual regularization
    δ                :: T # primal regularization
    K                :: SparseMatrixCSC{T,Int} # K2 matrix
    K_fact           :: LDLFactorizations.LDLFactorization{T,Int,Int,Int} # factorized K2
end</code></pre><p>Now you need to write a <code>RipQP.PreallocatedData</code> function that returns your type:</p><pre><code class="language-julia">function RipQP.PreallocatedData(sp :: SolverParams, fd :: RipQP.QM_FloatData{T},
                                id :: RipQP.QM_IntData,
                                iconf :: InputConfig{Tconf}) where {T&lt;:Real, Tconf&lt;:Real}

    ρ, δ = T(sp.ρ), T(sp.δ)
    K = spzeros(T, id.ncon+id.nvar, id.ncon + id.nvar)
    K[1:id.nvar, 1:id.nvar] = .-fd.Q .- ρ .* Diagonal(ones(T, id.nvar))
    K[1:id.nvar, id.nvar+1:end] = fd.AT
    K[diagind(K)[id.nvar+1:end]] .= δ

    K_fact = ldl_analyze(Symmetric(K, :U))
    K_fact = ldl_factorize!(Symmetric(K, :U), K_fact)
    K_fact.__factorized = true

    return PreallocatedData_K2basic(zeros(T, id.nvar),
                                    ρ,
                                    δ,
                                    K, #K
                                    K_fact #K_fact
                                    )
end</code></pre><p>Then, you need to write a <code>RipQP.update_pad!</code> function that will update the <code>RipQP.PreallocatedData</code> struct before computing the direction of descent.</p><pre><code class="language-julia">function RipQP.update_pad!(pad :: PreallocatedData_K2basic{T}, dda :: RipQP.DescentDirectionAllocs{T},
                           pt :: RipQP.Point{T}, itd :: RipQP.IterData{T},
                           fd :: RipQP.Abstract_QM_FloatData{T}, id :: RipQP.QM_IntData,
                           res :: RipQP.Residuals{T}, cnts :: RipQP.Counters,
                           T0 :: RipQP.DataType) where {T&lt;:Real}

    # update the diagonal of K2
    pad.D .= -pad.ρ
    pad.D[id.ilow] .-= pt.s_l ./ itd.x_m_lvar
    pad.D[id.iupp] .-= pt.s_u ./ itd.uvar_m_x
    pad.D .-= fd.Q[diagind(fd.Q)]
    pad.K[diagind(pad.K)[1:id.nvar]] = pad.D
    pad.K[diagind(pad.K)[id.nvar+1:end]] .= pad.δ

    # factorize K2
    ldl_factorize!(Symmetric(pad.K, :U), pad.K_fact)

end</code></pre><p>Finally, you need to write a <code>RipQP.solver!</code> function that compute directions of descent. Note that this function solves in-place the linear system by overwriting the direction of descent. That is why the direction of descent <code>itd.Δxy</code> (resp. <code>dda.Δxy_aff</code> for the Predictor step) countains the right hand side of the linear system to solve.</p><pre><code class="language-julia">function RipQP.solver!(pad :: PreallocatedData_K2basic{T},
                       dda :: RipQP.DescentDirectionAllocsPC{T}, pt :: RipQP.Point{T},
                       itd :: RipQP.IterData{T}, fd :: RipQP.Abstract_QM_FloatData{T},
                       id :: RipQP.QM_IntData, res :: RipQP.Residuals{T},
                       cnts :: RipQP.Counters, T0 :: DataType,
                       step :: Symbol) where {T&lt;:Real}

    if step == :aff # affine predictor step
        # solve the system and overwrite dda.Δxy_aff
        ldiv!(pad.K_fact, dda.Δxy_aff)
    else # for all other steps including the initial point
        # solve the system and overwrite itd.Δxy
        ldiv!(pad.K_fact, itd.Δxy)
    end

    return 0
end</code></pre><p>Then, you can use your solver:</p><pre><code class="language-julia">using QuadraticModels, QPSReader
qm = QuadraticModel(readqps(&quot;QAFIRO.SIF&quot;))
stats1 = ripqp(qm, iconf = RipQP.InputConfig(sp = K2basicLDLParams(1.0e-6, 1.0e-6)))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../API/">« API</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 June 2021 19:03">Tuesday 8 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
