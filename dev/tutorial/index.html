<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · RipQP.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RipQP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">RipQP.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../API/">API</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Input"><span>Input</span></a></li><li><a class="tocitem" href="#Logging"><span>Logging</span></a></li><li><a class="tocitem" href="#Change-configuration-and-tolerances"><span>Change configuration and tolerances</span></a></li><li><a class="tocitem" href="#Save-the-Interior-Point-system"><span>Save the Interior-Point system</span></a></li><li><a class="tocitem" href="#Advanced:-write-your-own-solver"><span>Advanced: write your own solver</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Input"><a class="docs-heading-anchor" href="#Input">Input</a><a id="Input-1"></a><a class="docs-heading-anchor-permalink" href="#Input" title="Permalink"></a></h2><p>RipQP uses the package <a href="https://github.com/JuliaSmoothOptimizers/QuadraticModels.jl">QuadraticModels.jl</a> to model convex quadratic problems.</p><p>Here is a basic example:</p><pre><code class="language-julia">using QuadraticModels, SparseArrays
Q = [6. 2. 1.
    2. 5. 2.
    1. 2. 4.]
c = [-8.; -3; -3]
A = [1. 0. 1.
    0. 2. 1.]
b = [0.; 3]
l = [0.;0;0]
u = [Inf; Inf; Inf]
QM = QuadraticModel(c, sparse(Q), A=A, lcon=b, ucon=b, lvar=l, uvar=u, c0=0., name=&quot;QM&quot;)</code></pre><pre class="documenter-example-output">QuadraticModels.QuadraticModel{Float64, Vector{Float64}}
  Problem name: QM
   All variables: ████████████████████ 3      All constraints: ████████████████████ 2     
            free: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 free: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           lower: ████████████████████ 3                lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
         low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0              low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           fixed: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                fixed: ████████████████████ 2     
          infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            nnzh: (  0.00% sparsity)   6               linear: ████████████████████ 2     
                                                    nonlinear: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
                                                         nnzj: (  0.00% sparsity)   6     

  Counters:
             obj: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 grad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 cons: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            jcon: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                jgrad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                  jac: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           jprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jtprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 hess: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           hprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                jhess: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jhprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
</pre><p>Once your <code>QuadraticModel</code> is loaded, you can simply solve it RipQP:</p><pre><code class="language-julia">using RipQP
stats = ripqp(QM)
println(stats)</code></pre><pre class="documenter-example-output">[ Info:   iter       obj      rgap      ‖rb‖      ‖rc‖     α_pri      α_du         μ     nprod
[ Info:      0   1.7e+01   2.3e+00   4.1e+00   5.5e+00   0.0e+00   0.0e+00   2.2e+01       0
[ Info:      1   1.2e+00   1.7e+00   1.8e-01   2.9e-01   9.6e-01   1.0e+00   1.5e+00       0
[ Info:      2   1.1e+00   1.4e-03   2.8e-04   2.7e-04   1.0e+00   1.0e+00   1.7e-03       0
[ Info:      3   1.1e+00   1.4e-06   2.8e-07   2.6e-07   1.0e+00   1.0e+00   1.7e-06       0
[ Info:      4   1.1e+00   1.4e-09   2.8e-10   2.6e-10   1.0e+00   1.0e+00   1.7e-09       0
Generic Execution stats
  status: solved to within acceptable tolerances
  objective value: 1.1249999992779633
  primal feasibility: 1.9503492283801082e-10
  dual feasibility: 3.7405456509986834e-10
  solution: [7.000014858691984e-11  1.499999999917326  1.2503477425109105e-10]
  multipliers: [-13.771719091319774  2.249999998782937]
  multipliers_L: [8.771719091339614  2.0632315350708096e-9  11.52171909256757]
  multipliers_U: [0.0  0.0  0.0]
  iterations: 16
  elapsed time: 11.479451179504395
  solver specific:
    absolute_iter_cnt: 4</pre><p>The <code>stats</code> output is a <a href="https://juliasmoothoptimizers.github.io/SolverCore.jl/dev/reference/#SolverCore.GenericExecutionStats">GenericExecutionStats</a>.</p><p>It is also possible to use the package <a href="https://github.com/JuliaSmoothOptimizers/QPSReader.jl">QPSReader.jl</a> in order to read convex quadratic problems in MPS or SIF formats:</p><pre><code class="language-julia">using QPSReader, QuadraticModels
QM = QuadraticModel(readqps(&quot;QAFIRO.SIF&quot;))</code></pre><h2 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h2><p>RipQP displays some logs at each iterate.</p><p>You can deactivate logging with</p><pre><code class="language-julia">stats = ripqp(QM, display = false)</code></pre><h2 id="Change-configuration-and-tolerances"><a class="docs-heading-anchor" href="#Change-configuration-and-tolerances">Change configuration and tolerances</a><a id="Change-configuration-and-tolerances-1"></a><a class="docs-heading-anchor-permalink" href="#Change-configuration-and-tolerances" title="Permalink"></a></h2><p>The <a href="../API/#RipQP.InputConfig"><code>RipQP.InputConfig</code></a> type allows the user to change the configuration of RipQP. For example, you can use the multi-precision mode without scaling with:</p><pre><code class="language-julia">stats = ripqp(QM, iconf = InputConfig(mode = :multi, scaling = false))</code></pre><p>You can also change the <a href="../API/#RipQP.InputTol"><code>RipQP.InputTol</code></a> type to change the tolerances for the stopping criteria:</p><pre><code class="language-julia">stats = ripqp(QM, itol = InputTol(max_iter = 100, ϵ_rb = 1.0e-4),
              iconf = InputConfig(mode = :multi, scaling = false))</code></pre><h2 id="Save-the-Interior-Point-system"><a class="docs-heading-anchor" href="#Save-the-Interior-Point-system">Save the Interior-Point system</a><a id="Save-the-Interior-Point-system-1"></a><a class="docs-heading-anchor-permalink" href="#Save-the-Interior-Point-system" title="Permalink"></a></h2><p>At every iteration, RipQP solves two linear systems with the default Predictor-Corrector method (the affine system and the  corrector-centering system), or one linear system with the Infeasible Path-Following method.</p><p>To save these systems, you can use:</p><pre><code class="language-julia">w = SystemWrite(write = true, name=&quot;test_&quot;, kfirst = 4, kgap=3) 
stats1 = ripqp(QM, iconf = InputConfig(w = w))</code></pre><p>This will save one matrix and the associated two right hand sides of the PC method every three iterations starting at  iteration four. Then, you can read the saved files with:</p><pre><code class="language-julia">using DelimitedFiles, MatrixMarket
K = MatrixMarket.mmread(&quot;test_K_iter4.mtx&quot;)
rhs_aff = readdlm(&quot;test_rhs_iter4_aff.rhs&quot;, Float64)[:]
rhs_cc =  readdlm(&quot;test_rhs_iter4_cc.rhs&quot;, Float64)[:] </code></pre><h2 id="Advanced:-write-your-own-solver"><a class="docs-heading-anchor" href="#Advanced:-write-your-own-solver">Advanced: write your own solver</a><a id="Advanced:-write-your-own-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-write-your-own-solver" title="Permalink"></a></h2><p>You can use your own solver to compute the direction of descent inside RipQP at each iteration. Here is a basic example using the package <a href="https://github.com/JuliaSmoothOptimizers/LDLFactorizations.jl"><code>LDLFactorizations.jl</code></a>.</p><p>First, you will need a <a href="../API/#RipQP.SolverParams"><code>RipQP.SolverParams</code></a> to define parameters for your solver:</p><pre><code class="language-julia">using RipQP, LinearAlgebra, LDLFactorizations, SparseArrays

struct K2basicLDLParams{T&lt;:Real} &lt;: SolverParams
    uplo   :: Symbol # mandatory, tells RipQP which triangle of the augmented system to store
    ρ      :: T # dual regularization
    δ      :: T # primal regularization
end</code></pre><p>Then, you will have to create a type that allocates space for your solver, and a constructor using the following parameters:</p><pre><code class="language-julia">mutable struct PreallocatedDataK2basic{T&lt;:Real, S} &lt;: RipQP.PreallocatedDataAugmented{T, S}
    D                :: S # temporary top-left diagonal of the K2 system
    ρ                :: T # dual regularization
    δ                :: T # primal regularization
    K                :: SparseMatrixCSC{T,Int} # K2 matrix
    K_fact           :: LDLFactorizations.LDLFactorization{T,Int,Int,Int} # factorized K2
end</code></pre><p>Now you need to write a <code>RipQP.PreallocatedData</code> function that returns your type:</p><pre><code class="language-julia">function RipQP.PreallocatedData(sp :: SolverParams, fd :: RipQP.QM_FloatData{T},
                                id :: RipQP.QM_IntData, itd :: RipQP.IterData{T},
                                pt :: RipQP.Point{T},
                                iconf :: InputConfig{Tconf}) where {T&lt;:Real, Tconf&lt;:Real}

    ρ, δ = T(sp.ρ), T(sp.δ)
    K = spzeros(T, id.ncon+id.nvar, id.ncon + id.nvar)
    K[1:id.nvar, 1:id.nvar] = .-fd.Q .- ρ .* Diagonal(ones(T, id.nvar))
    # A = Aᵀ of the input QuadraticModel since we use the upper triangle:
    K[1:id.nvar, id.nvar+1:end] = fd.A 
    K[diagind(K)[id.nvar+1:end]] .= δ

    K_fact = ldl_analyze(Symmetric(K, :U))
    @assert sp.uplo == :U # LDLFactorizations does not work with the lower triangle
    K_fact = ldl_factorize!(Symmetric(K, :U), K_fact)
    K_fact.__factorized = true

    return PreallocatedDataK2basic(zeros(T, id.nvar),
                                    ρ,
                                    δ,
                                    K, #K
                                    K_fact #K_fact
                                    )
end</code></pre><p>Then, you need to write a <code>RipQP.update_pad!</code> function that will update the <code>RipQP.PreallocatedData</code> struct before computing the direction of descent.</p><pre><code class="language-julia">function RipQP.update_pad!(pad :: PreallocatedDataK2basic{T}, dda :: RipQP.DescentDirectionAllocs{T},
                           pt :: RipQP.Point{T}, itd :: RipQP.IterData{T},
                           fd :: RipQP.Abstract_QM_FloatData{T}, id :: RipQP.QM_IntData,
                           res :: RipQP.Residuals{T}, cnts :: RipQP.Counters,
                           T0 :: RipQP.DataType) where {T&lt;:Real}

    # update the diagonal of K2
    pad.D .= -pad.ρ
    pad.D[id.ilow] .-= pt.s_l ./ itd.x_m_lvar
    pad.D[id.iupp] .-= pt.s_u ./ itd.uvar_m_x
    pad.D .-= fd.Q[diagind(fd.Q)]
    pad.K[diagind(pad.K)[1:id.nvar]] = pad.D
    pad.K[diagind(pad.K)[id.nvar+1:end]] .= pad.δ

    # factorize K2
    ldl_factorize!(Symmetric(pad.K, :U), pad.K_fact)

end</code></pre><p>Finally, you need to write a <code>RipQP.solver!</code> function that compute directions of descent. Note that this function solves in-place the linear system by overwriting the direction of descent. That is why the direction of descent <code>dd</code>  countains the right hand side of the linear system to solve.</p><pre><code class="language-julia">function RipQP.solver!(dd :: AbstractVector{T}, pad :: PreallocatedDataK2basic{T},
                       dda :: RipQP.DescentDirectionAllocsPC{T}, pt :: RipQP.Point{T},
                       itd :: RipQP.IterData{T}, fd :: RipQP.Abstract_QM_FloatData{T},
                       id :: RipQP.QM_IntData, res :: RipQP.Residuals{T},
                       cnts :: RipQP.Counters, T0 :: DataType,
                       step :: Symbol) where {T&lt;:Real}

    ldiv!(pad.K_fact, dd)
    return 0
end</code></pre><p>Then, you can use your solver:</p><pre><code class="language-julia">using QuadraticModels, QPSReader
qm = QuadraticModel(readqps(&quot;QAFIRO.SIF&quot;))
stats1 = ripqp(qm, iconf = RipQP.InputConfig(sp = K2basicLDLParams(:U, 1.0e-6, 1.0e-6)))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../API/">« API</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 2 December 2021 21:24">Thursday 2 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
