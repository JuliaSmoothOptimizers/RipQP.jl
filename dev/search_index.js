var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#RipQP","page":"API","title":"RipQP","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ripqp\ninput_config\ninput_tol","category":"page"},{"location":"api/#RipQP.ripqp","page":"API","title":"RipQP.ripqp","text":"stats = ripqp(QM :: QuadraticModel; iconf :: input_config{Int} = input_config(), \n              itol :: input_tol{Tu, Int} = input_tol(), \n              display :: Bool = true) where {Tu<:Real}\n\nMinimize a convex quadratic problem. Algorithm stops when the criteria in pdd, rb, and rc are valid. Returns a GenericExecutionStats containing information about the solved problem.\n\nQM :: QuadraticModel: problem to solve\niconf :: input_config{Int}: input RipQP configuration. See input_config{I}.\nitol :: input_tol{T, Int} input tolerances for the stopping criteria. See input_tol{T, I}.\ndisplay::Bool: activate/deactivate iteration data display\n\n\n\n\n\n","category":"function"},{"location":"api/#RipQP.input_config","page":"API","title":"RipQP.input_config","text":"Type to specify the configuration used by RipQP.\n\nmode :: Symbol: should be :mono to use the mono-precision mode, or :multi to use   the multi-precision mode (start in single precision and gradually transitions   to T0)\nregul :: Symbol: if :classic, then the regularization is performed prior the factorization,   if :dynamic, then the regularization is performed during the factorization, and if :none,   no regularization is used\nscaling :: Bool: activate/deactivate scaling of A and Q in QM0\nnormalize_rtol :: Bool = true : if true, the primal and dual tolerance for the stopping criteria    are normalized by the initial primal and dual residuals\nK :: Int: number of centrality corrections (set to -1 for automatic computation)\nrefinement :: Symbol : should be :zoom to use the zoom procedure, :multizoom to use the zoom procedure    with multi-precision (then mode should be :multi), ref to use the QP refinement procedure, multiref    to use the QP refinement procedure with multi_precision (then mode should be :multi), or none to avoid    refinements\ncreate_iterdata :: Function: used to create the iter_data type used for the iterations (including the system    to solve)\nsolve! :: Function : used to solve the system at each iteration\n\nThe constructor\n\niconf = input_config(; mode :: Symbol = :mono, regul :: Symbol = :classic, \n                     scaling :: Bool = true, normalize_rtol :: Bool = true, \n                     K :: I = 0, refinement :: Symbol = :none, max_ref :: I = 0, \n                     create_iterdata :: Function = create_iterdata_K2, \n                     solve! :: Function = solve_K2!) where {I<:Integer}\n\nreturns a input_config struct that shall be used to solve the input QuadraticModel with RipQP.\n\n\n\n\n\n","category":"type"},{"location":"api/#RipQP.input_tol","page":"API","title":"RipQP.input_tol","text":"Type to specify the tolerances used by RipQP.\n\nmax_iter :: Int: maximum number of iterations\nϵ_pdd: relative primal-dual difference tolerance\nϵ_rb: primal tolerance\nϵ_rc: dual tolerance\nmax_iter32, ϵ_pdd32, ϵ_rb32, ϵ_rc32: same as max_iter, ϵ_pdd, ϵ_rb and   ϵ_rc, but used for switching from single precision to double precision. They are   only usefull when mode=:multi\nmax_iter64, ϵ_pdd64, ϵ_rb64, ϵ_rc64: same as max_iter, ϵ_pdd, ϵ_rb and   ϵ_rc, but used for switching from double precision to quadruple precision. They   are only usefull when mode=:multi and T0=Float128\nϵ_rbz : primal transition tolerance for the zoom procedure, (used only if refinement=:zoom)\nϵ_Δx: step tolerance for the current point estimate (note: this criterion   is currently disabled)\nϵ_μ: duality measure tolerance (note: this criterion is currently disabled)\nmax_time: maximum time to solve the QP\n\nThe constructor\n\nitol = input_tol(;max_iter :: I = 200, max_iter32 :: I = 40, max_iter64 :: I = 180, \n                 ϵ_pdd :: T = 1e-8, ϵ_pdd32 :: T = 1e-2, ϵ_pdd64 :: T = 1e-4, \n                 ϵ_rb :: T = 1e-6, ϵ_rb32 :: T = 1e-4, ϵ_rb64 :: T = 1e-5, ϵ_rbz :: T = 1e-3,\n                 ϵ_rc :: T = 1e-6, ϵ_rc32 :: T = 1e-4, ϵ_rc64 :: T = 1e-5,\n                 ϵ_Δx :: T = 1e-16, ϵ_μ :: T = 1e-9) where {T<:Real, I<:Integer}\n\nreturns a input_tol struct that initializes the stopping criteria for RipQP.  The 32 and 64 characters refer to the stopping criteria in :multi mode for the transitions from Float32 to Float64  and Float64 to Float128 (if the input QuadraticModel is in Float128) respectively.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"#Home","page":"Home","title":"RipQP.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a solver for minimizing convex quadratic problems.","category":"page"}]
}
