<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · RipQP.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RipQP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">RipQP.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#RipQP"><span>RipQP</span></a></li><li><a class="tocitem" href="#Input-Types"><span>Input Types</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Preconditioners"><span>Preconditioners</span></a></li><li><a class="tocitem" href="#Factorizations"><span>Factorizations</span></a></li></ul></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../switch_solv/">Switching solvers</a></li><li><a class="tocitem" href="../multi_precision/">Multi-precision</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="RipQP"><a class="docs-heading-anchor" href="#RipQP">RipQP</a><a id="RipQP-1"></a><a class="docs-heading-anchor-permalink" href="#RipQP" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RipQP.ripqp" href="#RipQP.ripqp"><code>RipQP.ripqp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stats = ripqp(QM :: QuadraticModel{T0};
              itol = InputTol(T0), scaling = true, ps = true,
              normalize_rtol = true, kc = 0, mode = :mono, perturb = false,
              early_multi_stop = true,
              sp = (mode == :mono) ? K2LDLParams{T0}() : K2LDLParams{Float32}(),
              sp2 = nothing, sp3 = nothing, 
              solve_method = PC(), 
              history = false, w = SystemWrite(), display = true) where {T0&lt;:Real}</code></pre><p>Minimize a convex quadratic problem. Algorithm stops when the criteria in pdd, rb, and rc are valid. Returns a <a href="https://juliasmoothoptimizers.github.io/SolverCore.jl/dev/reference/#SolverCore.GenericExecutionStats">GenericExecutionStats</a>  containing information about the solved problem.</p><ul><li><code>QM :: QuadraticModel</code>: problem to solve</li><li><code>itol :: InputTol{T, Int}</code> input Tolerances for the stopping criteria. See <a href="#RipQP.InputTol"><code>RipQP.InputTol</code></a>.</li><li><code>scaling :: Bool</code>: activate/deactivate scaling of A and Q in <code>QM0</code></li><li><code>ps :: Bool</code> : activate/deactivate presolve</li><li><code>normalize_rtol :: Bool = true</code> : if <code>true</code>, the primal and dual tolerance for the stopping criteria    are normalized by the initial primal and dual residuals</li><li><code>kc :: Int</code>: number of centrality corrections (set to <code>-1</code> for automatic computation)</li><li><code>perturb :: Bool</code> : activate / deativate perturbation of the current point when μ is too small</li><li><code>mode :: Symbol</code>: should be <code>:mono</code> to use the mono-precision mode, <code>:multi</code> to use   the multi-precision mode (start in single precision and gradually transitions   to <code>T0</code>), <code>:zoom</code> to use the zoom procedure, <code>:multizoom</code> to use the zoom procedure    with multi-precision, <code>ref</code> to use the QP refinement procedure, or <code>multiref</code>    to use the QP refinement procedure with multi_precision</li><li><code>early_multi_stop :: Bool</code> : stop the iterations in lower precision systems earlier in multi-precision mode,   based on some quantities of the algorithm</li><li><code>sp :: SolverParams</code> : choose a solver to solve linear systems that occurs at each iteration and during the    initialization, see <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a></li><li><code>sp2 :: Union{Nothing, SolverParams}</code> and <code>sp3 :: Union{Nothing, SolverParams}</code> : choose second and third solvers   to solve linear systems that occurs at each iteration in the second and third solving phase.   When <code>mode != :mono</code>, leave to <code>nothing</code> if you want to keep using <code>sp</code>.   If <code>sp2</code> is not nothing, then <code>mode</code> should be set to <code>:multi</code>, <code>:multiref</code> or <code>multizoom</code>.  </li><li><code>solve_method :: SolveMethod</code> : method used to solve the system at each iteration, use <code>solve_method = PC()</code> to    use the Predictor-Corrector algorithm (default), and use <code>solve_method = IPF()</code> to use the Infeasible Path    Following algorithm.   <code>solve_method2 :: Union{Nothing, SolveMethod}</code> and  <code>solve_method3 :: Union{Nothing, SolveMethod}</code>   should be used with <code>sp2</code> and <code>sp3</code> to choose their respective solve method.   If they are <code>nothing</code>, then the solve method used is <code>solve_method</code>. </li><li><code>history :: Bool</code> : set to true to return the primal and dual norm histories, the primal-dual relative difference   history, and the number of products if using a Krylov method in the <code>solver_specific</code> field of the    <a href="https://juliasmoothoptimizers.github.io/SolverCore.jl/dev/reference/#SolverCore.GenericExecutionStats">GenericExecutionStats</a></li><li><code>w :: SystemWrite</code>: configure writing of the systems to solve (no writing is done by default), see <a href="#RipQP.SystemWrite"><code>RipQP.SystemWrite</code></a></li><li><code>display::Bool</code>: activate/deactivate iteration data display</li></ul><p>You can also use <code>ripqp</code> to solve a <a href="https://juliasmoothoptimizers.github.io/LLSModels.jl/stable/#LLSModels.LLSModel">LLSModel</a>:</p><pre><code class="language-none">stats = ripqp(LLS::LLSModel{T0}; mode = :mono,
              sp = (mode == :mono) ? K2LDLParams{T0}() : K2LDLParams{Float32}(), 
              kwargs...) where {T0 &lt;: Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/RipQP.jl#L42-L94">source</a></section></article><h2 id="Input-Types"><a class="docs-heading-anchor" href="#Input-Types">Input Types</a><a id="Input-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RipQP.InputTol" href="#RipQP.InputTol"><code>RipQP.InputTol</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to specify the tolerances used by RipQP.</p><ul><li><code>max_iter :: Int</code>: maximum number of iterations</li><li><code>ϵ_pdd</code>: relative primal-dual difference tolerance</li><li><code>ϵ_rb</code>: primal tolerance</li><li><code>ϵ_rc</code>: dual tolerance</li><li><code>max_iter1</code>, <code>ϵ_pdd1</code>, <code>ϵ_rb1</code>, <code>ϵ_rc1</code>: same as <code>max_iter</code>, <code>ϵ_pdd</code>, <code>ϵ_rb</code> and   <code>ϵ_rc</code>, but used for switching from <code>sp1</code> to <code>sp2</code> (or from single to double precision if <code>sp2</code> is <code>nothing</code>).   They are only usefull when <code>mode=:multi</code></li><li><code>max_iter2</code>, <code>ϵ_pdd2</code>, <code>ϵ_rb2</code>, <code>ϵ_rc2</code>: same as <code>max_iter</code>, <code>ϵ_pdd</code>, <code>ϵ_rb</code> and   <code>ϵ_rc</code>, but used for switching from <code>sp2</code> to <code>sp3</code> (or from double to quadruple precision if <code>sp3</code> is <code>nothing</code>).   They are only usefull when <code>mode=:multi</code> and/or <code>T0=Float128</code></li><li><code>ϵ_rbz</code> : primal transition tolerance for the zoom procedure, (used only if <code>refinement=:zoom</code>)</li><li><code>ϵ_Δx</code>: step tolerance for the current point estimate (note: this criterion   is currently disabled)</li><li><code>ϵ_μ</code>: duality measure tolerance (note: this criterion is currently disabled)</li><li><code>max_time</code>: maximum time to solve the QP</li></ul><p>The constructor</p><pre><code class="language-none">itol = InputTol(::Type{T};
                max_iter :: I = 200, max_iter1 :: I = 40, max_iter2 :: I = 180, 
                ϵ_pdd :: T = 1e-8, ϵ_pdd1 :: T = 1e-2, ϵ_pdd2 :: T = 1e-4, 
                ϵ_rb :: T = 1e-6, ϵ_rb1 :: T = 1e-4, ϵ_rb2 :: T = 1e-5, ϵ_rbz :: T = 1e-3,
                ϵ_rc :: T = 1e-6, ϵ_rc1 :: T = 1e-4, ϵ_rc2 :: T = 1e-5,
                ϵ_Δx :: T = 1e-16, ϵ_μ :: T = 1e-9) where {T&lt;:Real, I&lt;:Integer}

InputTol(; kwargs...) = InputTol(Float64; kwargs...)</code></pre><p>returns a <code>InputTol</code> struct that initializes the stopping criteria for RipQP.  The 1 and 2 characters refer to the transitions between the chosen solvers in <code>:multi</code>. If <code>sp2</code> and <code>sp3</code> are not precised when calling <a href="#RipQP.ripqp"><code>RipQP.ripqp</code></a>, they refer to transitions between floating-point systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/types_definition.jl#L96-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.SystemWrite" href="#RipQP.SystemWrite"><code>RipQP.SystemWrite</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to write the matrix (.mtx format) and the right hand side (.rhs format) of the system to solve at each iteration.</p><ul><li><code>write::Bool</code>: activate/deactivate writing of the system </li><li><code>name::String</code>: name of the sytem to solve </li><li><code>kfirst::Int</code>: first iteration where a system should be written</li><li><code>kgap::Int</code>: iteration gap between two problem writings</li></ul><p>The constructor</p><pre><code class="language-none">SystemWrite(; write = false, name = &quot;&quot;, kfirst = 0, kgap = 1)</code></pre><p>returns a <code>SystemWrite</code> structure that should be used to tell RipQP to save the system.  See the tutorial for more information. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/types_definition.jl#L42-L56">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RipQP.SolverParams" href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for tuning the parameters of the different solvers.  Each solver has its own <code>SolverParams</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/types_definition.jl#L36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K2LDLParams" href="#RipQP.K2LDLParams"><code>RipQP.K2LDLParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K2 formulation with a LDLᵀ factorization. The package <a href="https://github.com/JuliaSmoothOptimizers/LDLFactorizations.jl"><code>LDLFactorizations.jl</code></a> is used by default. The outer constructor </p><pre><code class="language-none">sp = K2LDLParams(; fact_alg = LDLFact(regul = :classic),
                 ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5,
                 ρ_min = sqrt(eps()), δ_min = sqrt(eps()),
                 safety_dist_bnd = true)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. <code>regul = :dynamic</code> uses a dynamic regularization (the regularization is only added if the LDLᵀ factorization  encounters a pivot that has a small magnitude). <code>regul = :none</code> uses no regularization (not recommended). When <code>regul = :classic</code>, the parameters <code>ρ0</code> and <code>δ0</code> are used to choose the initial regularization values. <code>fact_alg</code> should be a <a href="#RipQP.AbstractFactorization"><code>RipQP.AbstractFactorization</code></a>. <code>safety_dist_bnd = true</code>: boolean used to determine if the regularization values should be updated  (or if the algorithm should transition to another solver in multi mode) if the variables are too close  from their bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/augmented/K2LDL.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K2_5LDLParams" href="#RipQP.K2_5LDLParams"><code>RipQP.K2_5LDLParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K2.5 formulation with a LDLᵀ factorization. The package <a href="https://github.com/JuliaSmoothOptimizers/LDLFactorizations.jl"><code>LDLFactorizations.jl</code></a> is used by default. The outer constructor </p><pre><code class="language-none">sp = K2_5LDLParams(; fact_alg = LDLFact(regul = :classic), ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. <code>regul = :dynamic</code> uses a dynamic regularization (the regularization is only added if the LDLᵀ factorization  encounters a pivot that has a small magnitude). <code>regul = :none</code> uses no regularization (not recommended). When <code>regul = :classic</code>, the parameters <code>ρ0</code> and <code>δ0</code> are used to choose the initial regularization values. <code>fact_alg</code> should be a <a href="#RipQP.AbstractFactorization"><code>RipQP.AbstractFactorization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/augmented/K2_5LDL.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K2KrylovParams" href="#RipQP.K2KrylovParams"><code>RipQP.K2KrylovParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K2 formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K2KrylovParams(; uplo = :L, kmethod = :minres, preconditioner = Identity(),
               rhs_scale = true, form_mat = false, equilibrate = false,
               atol0 = 1.0e-4, rtol0 = 1.0e-4, 
               atol_min = 1.0e-10, rtol_min = 1.0e-10,
               ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5, 
               ρ_min = 1e2 * sqrt(eps()), δ_min = 1e2 * sqrt(eps()),
               itmax = 0, memory = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/augmented/K2Krylov.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K2_5KrylovParams" href="#RipQP.K2_5KrylovParams"><code>RipQP.K2_5KrylovParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K2.5 formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K2_5KrylovParams(; uplo = :L, kmethod = :minres, preconditioner = Identity(),
                 rhs_scale = true,
                 atol0 = 1.0e-4, rtol0 = 1.0e-4, 
                 atol_min = 1.0e-10, rtol_min = 1.0e-10,
                 ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5, 
                 ρ_min = 1e2 * sqrt(eps()), δ_min = 1e2 * sqrt(eps()),
                 itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:minres</code></li><li><code>:minres_qlp</code></li><li><code>:symmlq</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/augmented/K2_5Krylov.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K2StructuredParams" href="#RipQP.K2StructuredParams"><code>RipQP.K2StructuredParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K2 formulation with a structured Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>. This only works for solving Linear Problems. The outer constructor </p><pre><code class="language-none">K2StructuredParams(; uplo = :L, kmethod = :trimr, rhs_scale = true, 
                   atol0 = 1.0e-4, rtol0 = 1.0e-4,
                   atol_min = 1.0e-10, rtol_min = 1.0e-10, 
                   ρ_min = 1e2 * sqrt(eps()), δ_min = 1e2 * sqrt(eps()),
                   itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:tricg</code></li><li><code>:trimr</code></li><li><code>:gpmr</code></li></ul><p>The <code>mem</code> argument sould be used only with <code>gpmr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/augmented/K2Structured.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K2_5StructuredParams" href="#RipQP.K2_5StructuredParams"><code>RipQP.K2_5StructuredParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K2.5 formulation with a structured Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>. This only works for solving Linear Problems. The outer constructor </p><pre><code class="language-none">K2_5StructuredParams(; uplo = :L, kmethod = :trimr, rhs_scale = true,
                     atol0 = 1.0e-4, rtol0 = 1.0e-4,
                     atol_min = 1.0e-10, rtol_min = 1.0e-10,
                     ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5,
                     ρ_min = 1e2 * sqrt(eps()), δ_min = 1e2 * sqrt(eps()),
                     itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:tricg</code></li><li><code>:trimr</code></li><li><code>:gpmr</code></li></ul><p>The <code>mem</code> argument sould be used only with <code>gpmr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/augmented/K2_5Structured.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K3KrylovParams" href="#RipQP.K3KrylovParams"><code>RipQP.K3KrylovParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K3 formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K3KrylovParams(; uplo = :L, kmethod = :qmr, preconditioner = Identity(),
               rhs_scale = true,
               atol0 = 1.0e-4, rtol0 = 1.0e-4,
               atol_min = 1.0e-10, rtol_min = 1.0e-10,
               ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5,
               ρ_min = 1e3 * sqrt(eps()), δ_min = 1e4 * sqrt(eps()),
               itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:qmr</code></li><li><code>:bicgstab</code></li><li><code>:usymqr</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/Newton/K3Krylov.jl#L7-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K3SKrylovParams" href="#RipQP.K3SKrylovParams"><code>RipQP.K3SKrylovParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K3S formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K3SKrylovParams(; uplo = :L, kmethod = :minres, preconditioner = Identity(),
                 rhs_scale = true,
                 atol0 = 1.0e-4, rtol0 = 1.0e-4,
                 atol_min = 1.0e-10, rtol_min = 1.0e-10,
                 ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5,
                 ρ_min = 1e3 * sqrt(eps()), δ_min = 1e4 * sqrt(eps()),
                 itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:minres</code></li><li><code>:minres_qlp</code></li><li><code>:symmlq</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/Newton/K3SKrylov.jl#L9-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K3SStructuredParams" href="#RipQP.K3SStructuredParams"><code>RipQP.K3SStructuredParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K3S formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K3SStructuredParams(; uplo = :U, kmethod = :trimr, rhs_scale = true,
                     atol0 = 1.0e-4, rtol0 = 1.0e-4, 
                     atol_min = 1.0e-10, rtol_min = 1.0e-10,
                     ρ0 =  sqrt(eps()) * 1e3, δ0 = sqrt(eps()) * 1e4,
                     ρ_min = 1e4 * sqrt(eps()), δ_min = 1e4 * sqrt(eps()),
                     itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:tricg</code></li><li><code>:trimr</code></li><li><code>:gpmr</code></li></ul><p>The <code>mem</code> argument sould be used only with <code>gpmr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/Newton/K3SStructured.jl#L9-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K3_5KrylovParams" href="#RipQP.K3_5KrylovParams"><code>RipQP.K3_5KrylovParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K3.5 formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K3_5KrylovParams(; uplo = :L, kmethod = :minres, preconditioner = Identity(),
                 rhs_scale = true,
                 atol0 = 1.0e-4, rtol0 = 1.0e-4,
                 atol_min = 1.0e-10, rtol_min = 1.0e-10,
                 ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5,
                 ρ_min = 1e3 * sqrt(eps()), δ_min = 1e4 * sqrt(eps()),
                 itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:minres</code></li><li><code>:minres_qlp</code></li><li><code>:symmlq</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/Newton/K3_5Krylov.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K3_5StructuredParams" href="#RipQP.K3_5StructuredParams"><code>RipQP.K3_5StructuredParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K3.5 formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K3_5StructuredParams(; uplo = :U, kmethod = :trimr, rhs_scale = true,
                     atol0 = 1.0e-4, rtol0 = 1.0e-4, 
                     atol_min = 1.0e-10, rtol_min = 1.0e-10,
                     ρ0 =  sqrt(eps()) * 1e3, δ0 = sqrt(eps()) * 1e4,
                     ρ_min = 1e4 * sqrt(eps()), δ_min = 1e4 * sqrt(eps()),
                     itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:tricg</code></li><li><code>:trimr</code></li><li><code>:gpmr</code></li></ul><p>The <code>mem</code> argument sould be used only with <code>gpmr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/Newton/K3_5Structured.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K1CholParams" href="#RipQP.K1CholParams"><code>RipQP.K1CholParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K1 formulation with a Cholesky factorization. The outer constructor </p><pre><code class="language-none">sp = K1CholParams(; fact_alg = LDLFact(regul = :classic),
                  ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5,
                  ρ_min = sqrt(eps()), δ_min = sqrt(eps()))</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/normal/K1Chol.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K1KrylovParams" href="#RipQP.K1KrylovParams"><code>RipQP.K1KrylovParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K1 formulation with a Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>.  The outer constructor </p><pre><code class="language-none">K1KrylovParams(; uplo = :L, kmethod = :cg, preconditioner = Identity(),
               rhs_scale = true,
               atol0 = 1.0e-4, rtol0 = 1.0e-4, 
               atol_min = 1.0e-10, rtol_min = 1.0e-10,
               ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5, 
               ρ_min = 1e2 * sqrt(eps()), δ_min = 1e2 * sqrt(eps()),
               itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:cg</code></li><li><code>:cg_lanczos</code></li><li><code>:cr</code></li><li><code>:minres</code></li><li><code>:minres_qlp</code></li><li><code>:symmlq</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/normal/K1Krylov.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K1CholDenseParams" href="#RipQP.K1CholDenseParams"><code>RipQP.K1CholDenseParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K1 formulation with a dense Cholesky factorization. The input QuadraticModel should have <code>lcon .== ucon</code>. The outer constructor </p><pre><code class="language-none">sp = K1CholDenseParams(; ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/normal/K1CholDense.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K2LDLDenseParams" href="#RipQP.K2LDLDenseParams"><code>RipQP.K2LDLDenseParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K2 formulation with a LDLᵀ factorization.  The outer constructor </p><pre><code class="language-none">sp = K2LDLDenseParams(; ρ0 = sqrt(eps()) * 1e5, δ0 = sqrt(eps()) * 1e5)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/augmented/K2LDLDense.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K1_1StructuredParams" href="#RipQP.K1_1StructuredParams"><code>RipQP.K1_1StructuredParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K1.1 formulation with a structured Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>. This only works for solving Linear Problems. The outer constructor </p><pre><code class="language-none">K1_1StructuredParams(; uplo = :L, kmethod = :lsqr, rhs_scale = true,
                     atol0 = 1.0e-4, rtol0 = 1.0e-4,
                     atol_min = 1.0e-10, rtol_min = 1.0e-10, 
                     ρ_min = 1e3 * sqrt(eps()), δ_min = 1e4 * sqrt(eps()),
                     itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:lslq</code></li><li><code>:lsqr</code></li><li><code>:lsmr</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/normal/K1_1Structured.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.K1_2StructuredParams" href="#RipQP.K1_2StructuredParams"><code>RipQP.K1_2StructuredParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to use the K1.2 formulation with a structured Krylov method, using the package  <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl"><code>Krylov.jl</code></a>. This only works for solving Linear Problems. The outer constructor </p><pre><code class="language-none">K1_2StructuredParams(; uplo = :L, kmethod = :craig, rhs_scale = true,
                     atol0 = 1.0e-4, rtol0 = 1.0e-4,
                     atol_min = 1.0e-10, rtol_min = 1.0e-10, 
                     ρ_min = 1e3 * sqrt(eps()), δ_min = 1e4 * sqrt(eps()),
                     itmax = 0, mem = 20)</code></pre><p>creates a <a href="#RipQP.SolverParams"><code>RipQP.SolverParams</code></a>. The available methods are:</p><ul><li><code>:lnlq</code></li><li><code>:craig</code></li><li><code>:craigmr</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/normal/K1_2Structured.jl#L3-L21">source</a></section></article><h2 id="Preconditioners"><a class="docs-heading-anchor" href="#Preconditioners">Preconditioners</a><a id="Preconditioners-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioners" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RipQP.AbstractPreconditioner" href="#RipQP.AbstractPreconditioner"><code>RipQP.AbstractPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for the preconditioners used with a solver using a Krylov method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/preconditioners/abstract-precond.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.Identity" href="#RipQP.Identity"><code>RipQP.Identity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">preconditioner = Identity()</code></pre><p>Tells RipQP not to use a preconditioner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/preconditioners/identity.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.Jacobi" href="#RipQP.Jacobi"><code>RipQP.Jacobi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">preconditioner = Jacobi()</code></pre><p>Preconditioner using the inverse of the diagonal of the system to solve. Works with:</p><ul><li><a href="#RipQP.K2KrylovParams"><code>K2KrylovParams</code></a></li><li><a href="#RipQP.K2_5KrylovParams"><code>K2_5KrylovParams</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/preconditioners/jacobi.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.Equilibration" href="#RipQP.Equilibration"><code>RipQP.Equilibration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">preconditioner = Equilibration()</code></pre><p>Preconditioner using the equilibration algorithm in infinity norm. Works with:</p><ul><li><a href="#RipQP.K2KrylovParams"><code>K2KrylovParams</code></a></li><li><a href="#RipQP.K3SKrylovParams"><code>K3SKrylovParams</code></a></li><li><a href="#RipQP.K3_5KrylovParams"><code>K3_5KrylovParams</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/preconditioners/equilibration.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.LDL" href="#RipQP.LDL"><code>RipQP.LDL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">preconditioner = LDL(; T = Float32, pos = :C, warm_start = true, fact_alg = LDLFact())</code></pre><p>Preconditioner for <a href="#RipQP.K2KrylovParams"><code>K2KrylovParams</code></a> using a LDL factorization in precision <code>T</code>. The <code>pos</code> argument is used to choose the type of preconditioning with an unsymmetric Krylov method. It can be <code>:C</code> (center), <code>:L</code> (left) or <code>:R</code> (right). The <code>warm_start</code> argument tells RipQP to solve the system with the LDL factorization before using the Krylov method with the LDLFactorization as a preconditioner. <code>fact_alg</code> should be a <a href="#RipQP.AbstractFactorization"><code>RipQP.AbstractFactorization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/preconditioners/LDL.jl#L3-L11">source</a></section></article><h2 id="Factorizations"><a class="docs-heading-anchor" href="#Factorizations">Factorizations</a><a id="Factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#Factorizations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RipQP.AbstractFactorization" href="#RipQP.AbstractFactorization"><code>RipQP.AbstractFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type to select a factorization algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/sparse_fact_utils/abstract-factorization.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.LDLFact" href="#RipQP.LDLFact"><code>RipQP.LDLFact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">fact_alg = LDLFact(; regul = :classic)</code></pre><p>Choose <a href="https://github.com/JuliaSmoothOptimizers/LDLFactorizations.jl"><code>LDLFactorizations.jl</code></a> to compute factorizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/sparse_fact_utils/abstract-factorization.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.CholmodFact" href="#RipQP.CholmodFact"><code>RipQP.CholmodFact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">fact_alg = CholmodFact(; regul = :classic)</code></pre><p>Choose <code>ldlt</code> from Cholmod to compute factorizations. <code>using SuiteSparse</code> should be used before <code>using RipQP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/sparse_fact_utils/abstract-factorization.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.QDLDLFact" href="#RipQP.QDLDLFact"><code>RipQP.QDLDLFact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">fact_alg = QDLDLFact(; regul = :classic)</code></pre><p>Choose <a href="https://github.com/oxfordcontrol/QDLDL.jl"><code>QDLDL.jl</code></a> to compute factorizations. <code>using QDLDL</code> should be used before <code>using RipQP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/sparse_fact_utils/abstract-factorization.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.HSLMA57Fact" href="#RipQP.HSLMA57Fact"><code>RipQP.HSLMA57Fact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">fact_alg = HSLMA57Fact(; regul = :classic)</code></pre><p>Choose <a href="https://github.com/JuliaSmoothOptimizers/HSL.jl"><code>HSL.jl</code></a> MA57 to compute factorizations. <code>using HSL</code> should be used before <code>using RipQP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/sparse_fact_utils/abstract-factorization.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.HSLMA97Fact" href="#RipQP.HSLMA97Fact"><code>RipQP.HSLMA97Fact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">fact_alg = HSLMA97Fact(; regul = :classic)</code></pre><p>Choose <a href="https://github.com/JuliaSmoothOptimizers/HSL.jl"><code>HSL.jl</code></a> MA57 to compute factorizations. <code>using HSL</code> should be used before <code>using RipQP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/sparse_fact_utils/abstract-factorization.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RipQP.LLDLFact" href="#RipQP.LLDLFact"><code>RipQP.LLDLFact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">fact_alg = LLDLFact(; regul = :classic, mem = 0, droptol = 0.0)</code></pre><p>Choose <a href="https://github.com/JuliaSmoothOptimizers/LimitedLDLFactorizations.jl"><code>LimitedLDLFactorizations.jl</code></a> to compute factorizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/RipQP.jl/blob/23e70a0fcbea92d57cfeefd29678d020ca28c224/src/iterations/solvers/sparse_fact_utils/abstract-factorization.jl#L99-L102">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorial/">Tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 27 October 2022 15:34">Thursday 27 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
